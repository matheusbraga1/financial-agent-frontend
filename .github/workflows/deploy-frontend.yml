name: CI/CD - Deploy Frontend to Production

on:
  push:
    branches: [main, master]
    paths:
      - 'src/**'
      - 'public/**'
      - 'package*.json'
      - 'vite.config.js'
      - 'Dockerfile'
      - 'nginx/**'
      - 'docker-compose.yml'
      - '.github/workflows/deploy-frontend.yml'

  workflow_dispatch:

env:
  DOCKER_BUILDKIT: 1
  IMAGE_NAME: financial-agent-frontend
  CONTAINER_NAME: financial-agent-frontend

jobs:
  # ============================================================================
  # Stage 1: Code Quality & Linting
  # ============================================================================
  lint:
    name: Code Quality & Linting
    runs-on: self-hosted

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js environment
        run: |
          # Verifica se Node.js 20 est√° instalado
          if ! command -v node &> /dev/null || [[ "$(node -v)" != v20* ]]; then
            echo "‚ö†Ô∏è  Node.js 20 n√£o encontrado. Por favor, instale Node.js 20."
            exit 1
          fi
          echo "‚úÖ Node.js $(node -v) encontrado"
          echo "‚úÖ npm $(npm -v) encontrado"

      - name: Cache node_modules
        id: cache-node-modules
        run: |
          # Cria hash baseado no package-lock.json para cache inteligente
          CACHE_KEY=$(md5sum package-lock.json 2>/dev/null | awk '{print $1}' || echo "no-lock")
          CACHE_DIR="$HOME/.npm-cache/financial-agent-frontend-${CACHE_KEY}"

          if [ -d "$CACHE_DIR/node_modules" ]; then
            echo "‚úÖ Restoring cached node_modules..."
            cp -r "$CACHE_DIR/node_modules" ./
            echo "cached=true" >> $GITHUB_OUTPUT
          else
            echo "üì¶ Cache miss - node_modules will be installed"
            echo "cached=false" >> $GITHUB_OUTPUT
          fi

      - name: Install dependencies
        if: steps.cache-node-modules.outputs.cached != 'true'
        run: |
          echo "üì¶ Installing dependencies..."
          npm ci --prefer-offline --no-audit

      - name: Save cache
        if: steps.cache-node-modules.outputs.cached != 'true'
        run: |
          CACHE_KEY=$(md5sum package-lock.json 2>/dev/null | awk '{print $1}' || echo "no-lock")
          CACHE_DIR="$HOME/.npm-cache/financial-agent-frontend-${CACHE_KEY}"
          mkdir -p "$CACHE_DIR"
          cp -r node_modules "$CACHE_DIR/"
          echo "‚úÖ Cache saved for future builds"

      - name: Run ESLint
        run: npm run lint
        continue-on-error: true

      - name: Build test
        env:
          VITE_API_URL: http://192.168.1.150/api/v1
          VITE_ENABLE_LOGS: false
          VITE_APP_VERSION: ${{ github.sha }}
        run: |
          echo "üî® Testing build..."
          npm run build:prod

      - name: Check build output
        run: |
          echo "‚úÖ Build completed successfully"
          ls -lah dist/
          du -sh dist/

  # ============================================================================
  # Stage 2: Build Docker Image
  # ============================================================================
  build:
    name: Build Docker Image
    runs-on: self-hosted
    needs: lint

    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check disk space
        run: |
          echo "üìä Checking available disk space..."
          df -h /

          AVAILABLE=$(df / | tail -1 | awk '{print $4}' | sed 's/G//')
          if [ "${AVAILABLE%.*}" -lt 10 ]; then
            echo "‚ö†Ô∏è  WARNING: Less than 10GB available"
            echo "Running cleanup..."
            docker image prune -a -f
            docker container prune -f
            docker builder prune -f
          else
            echo "‚úÖ Sufficient disk space available"
          fi

      - name: Generate image metadata
        id: meta
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="prod-${SHORT_SHA}-${TIMESTAMP}"
          echo "tags=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "üì¶ Building image with tag: ${IMAGE_TAG}"

      - name: Build Docker image
        env:
          COMMIT_SHA: ${{ github.sha }}
          IMAGE_TAG: ${{ steps.meta.outputs.tags }}
        run: |
          echo "üî® Building Docker image..."
          docker build \
            --build-arg VITE_API_URL=http://192.168.1.150/api/v1 \
            --build-arg VITE_ENABLE_LOGS=false \
            --build-arg VITE_APP_VERSION=$COMMIT_SHA \
            -t ${IMAGE_NAME}:${IMAGE_TAG} \
            -t ${IMAGE_NAME}:latest \
            -f Dockerfile .

      - name: Verify image
        run: |
          echo "üîç Verifying built image..."
          docker images | grep ${IMAGE_NAME}
          echo "‚úÖ Image built successfully"

  # ============================================================================
  # Stage 3: Deploy to Production
  # ============================================================================
  deploy:
    name: Deploy to Production
    runs-on: self-hosted
    needs: build
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Ensure Docker network exists
        run: |
          echo "üîç Checking Docker network..."
          if ! docker network ls | grep -q financial-agent-network; then
            echo "üì¶ Creating network financial-agent-network..."
            docker network create financial-agent-network
            echo "‚úÖ Network created"
          else
            echo "‚úÖ Network financial-agent-network already exists"
          fi

      - name: Backup current deployment
        run: |
          echo "üì¶ Creating backup of current deployment..."

          # Backup da imagem atual se existir
          if docker ps -a | grep -q ${CONTAINER_NAME}; then
            CURRENT_IMAGE=$(docker inspect ${CONTAINER_NAME} --format='{{.Image}}')
            docker tag $CURRENT_IMAGE ${IMAGE_NAME}:backup-$(date +%Y%m%d-%H%M%S) || true
            echo "‚úÖ Backup created"
          else
            echo "‚ÑπÔ∏è  No previous deployment found"
          fi

      - name: Stop current container
        run: |
          echo "‚èπÔ∏è  Stopping current container..."
          docker stop ${CONTAINER_NAME} || true
          docker rm ${CONTAINER_NAME} || true
          echo "‚úÖ Container stopped"

      - name: Create frontend volume if not exists
        run: |
          if ! docker volume ls | grep -q financial-agent-frontend-static; then
            echo "üì¶ Creating volume financial-agent-frontend-static..."
            docker volume create financial-agent-frontend-static
          else
            echo "‚úÖ Volume already exists"
          fi

      - name: Start new container
        env:
          IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
        run: |
          echo "üöÄ Starting new container..."
          docker run -d \
            --name ${CONTAINER_NAME} \
            --network financial-agent-network \
            --restart unless-stopped \
            --log-driver json-file \
            --log-opt max-size=10m \
            --log-opt max-file=3 \
            -v financial-agent-frontend-static:/app/dist \
            ${IMAGE_NAME}:${IMAGE_TAG}

          echo "‚úÖ Container started"
          echo "‚ÑπÔ∏è  Static files available in shared volume"

      - name: Wait for container to be ready
        run: |
          echo "‚è≥ Waiting for container to be ready..."
          sleep 10

      - name: Verify static files in volume
        run: |
          echo "üì¶ Verifying static files in shared volume..."

          # Verificar se os arquivos est√£o no volume
          docker run --rm \
            -v financial-agent-frontend-static:/files:ro \
            alpine ls -lah /files/

          echo "‚úÖ Static files verified"

      - name: Update nginx container with new files
        run: |
          echo "üîÑ Updating Nginx with new frontend files..."

          # Verificar se nginx est√° rodando no docker-compose
          if docker ps | grep -q financial-agent-nginx; then
            # Nginx do backend precisa ser reiniciado para pegar o volume atualizado
            echo "‚ÑπÔ∏è  Nginx is running via docker-compose"
            echo "‚ö†Ô∏è  You may need to run 'docker-compose restart nginx' in the backend directory"
            echo "‚ö†Ô∏è  Or update backend's docker-compose to mount the frontend volume"
          else
            echo "‚ÑπÔ∏è  Nginx will pick up files from shared volume automatically"
          fi

      - name: Health check
        run: |
          echo "üè• Running health checks..."

          MAX_ATTEMPTS=12
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            # Verificar se o container est√° healthy
            if docker inspect ${CONTAINER_NAME} --format='{{.State.Health.Status}}' 2>/dev/null | grep -q "healthy"; then
              echo "‚úÖ Container health check passed!"
              break
            fi

            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS - waiting for container to be healthy..."
            sleep 5

            if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "‚ùå Health check failed!"
              echo "üìã Container logs:"
              docker logs --tail 50 ${CONTAINER_NAME}
              exit 1
            fi
          done

      - name: Cleanup old images
        run: |
          echo "üßπ Cleaning up old images..."

          # Mant√©m apenas as √∫ltimas 5 imagens tagged (mais seguro)
          docker images ${IMAGE_NAME} --format "{{.ID}} {{.Tag}}" | \
            grep -v "latest\|backup" | \
            tail -n +6 | \
            awk '{print $1}' | \
            xargs -r docker rmi -f 2>/dev/null || true

          # Remove apenas imagens dangling (sem tag)
          docker image prune -f

          echo "‚úÖ Cleanup completed"
          echo "üìä Remaining images:"
          docker images ${IMAGE_NAME} --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

  # ============================================================================
  # Stage 4: Post-Deploy Validation
  # ============================================================================
  validate:
    name: Post-Deploy Validation
    runs-on: self-hosted
    needs: deploy

    steps:
      - name: Container status check
        run: |
          echo "üîç Checking container status..."

          if docker ps | grep -q ${CONTAINER_NAME}; then
            echo "‚úÖ Container is running"
          else
            echo "‚ùå Container is not running"
            exit 1
          fi

      - name: Application health check
        run: |
          echo "üè• Testing application health..."

          # Teste 1: Verificar se o container do frontend est√° healthy
          echo "Testing container health status..."
          if docker inspect ${CONTAINER_NAME} --format='{{.State.Health.Status}}' 2>/dev/null | grep -q "healthy"; then
            echo "‚úÖ Frontend container is healthy"
          else
            echo "‚ö†Ô∏è  Frontend container health check inconclusive"
          fi

          # Teste 2: Verificar arquivos no volume
          echo "Testing static files availability..."
          FILE_COUNT=$(docker run --rm -v financial-agent-frontend-static:/files:ro alpine sh -c "ls /files/ | wc -l")
          if [ "$FILE_COUNT" -gt 0 ]; then
            echo "‚úÖ Static files present in volume ($FILE_COUNT files/folders)"
          else
            echo "‚ùå No static files found in volume"
            exit 1
          fi

          # Teste 3: Health check via Nginx
          echo "Testing health via Nginx..."
          response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost/health 2>/dev/null || echo "000")
          if [ "$response" = "200" ]; then
            echo "‚úÖ Nginx health endpoint returned 200"
          else
            echo "‚ö†Ô∏è  Nginx health check returned status $response (may need backend restart)"
          fi

      - name: Network connectivity check
        run: |
          echo "üåê Testing network connectivity..."

          # Verifica se consegue acessar a aplica√ß√£o via rede externa
          response=$(curl -s -o /dev/null -w "%{http_code}" http://192.168.1.150)
          if [ "$response" = "200" ]; then
            echo "‚úÖ Application accessible via network (status: $response)"
          else
            echo "‚ö†Ô∏è  Network accessibility returned status $response"
          fi

      - name: Deployment summary
        run: |
          echo "=================================="
          echo "‚úÖ Deployment completed successfully!"
          echo "=================================="
          echo "üì¶ Container: ${CONTAINER_NAME}"
          echo "üåê Frontend URL: http://192.168.1.150"
          echo "üè• Health Check: http://192.168.1.150/health/frontend"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üè∑Ô∏è  Image Tag: ${{ needs.deploy.outputs.image_tag }}"
          echo ""
          echo "üìã Container details:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Image}}" | grep ${CONTAINER_NAME}
          echo ""
          echo "üíæ Disk usage:"
          df -h / | grep -E 'Filesystem|/$'

  # ============================================================================
  # Rollback on Failure
  # ============================================================================
  rollback:
    name: Rollback on Failure
    runs-on: self-hosted
    needs: [deploy, validate]
    if: failure()

    steps:
      - name: Stop failed deployment
        run: |
          echo "‚ö†Ô∏è  Deployment failed - initiating rollback..."
          docker stop ${CONTAINER_NAME} || true
          docker rm ${CONTAINER_NAME} || true

      - name: Ensure Docker network exists
        run: |
          if ! docker network ls | grep -q financial-agent-network; then
            echo "Creating network financial-agent-network..."
            docker network create financial-agent-network
          fi

      - name: Restore previous deployment
        run: |
          # Encontra a imagem de backup mais recente
          BACKUP_IMAGE=$(docker images ${IMAGE_NAME} --format "{{.Repository}}:{{.Tag}}" | grep backup | head -n 1)

          if [ -z "$BACKUP_IMAGE" ]; then
            echo "‚ùå No backup image found for rollback"

            # Tenta usar a pen√∫ltima imagem tagged
            PREVIOUS_IMAGE=$(docker images ${IMAGE_NAME} --format "{{.ID}}" | sed -n '2p')

            if [ -z "$PREVIOUS_IMAGE" ]; then
              echo "‚ùå No previous image found"
              exit 1
            fi

            echo "üì¶ Rolling back to previous image: $PREVIOUS_IMAGE"
            BACKUP_IMAGE=$PREVIOUS_IMAGE
          else
            echo "üì¶ Rolling back to backup: $BACKUP_IMAGE"
          fi

          docker run -d \
            --name ${CONTAINER_NAME} \
            --network financial-agent-network \
            --restart unless-stopped \
            --log-driver json-file \
            --log-opt max-size=10m \
            --log-opt max-file=3 \
            -v financial-agent-frontend-static:/app/dist \
            $BACKUP_IMAGE

          echo "‚úÖ Rollback completed"
          echo "‚ÑπÔ∏è  Static files restored to shared volume"

      - name: Verify rollback
        run: |
          echo "üîç Verifying rollback..."
          sleep 10

          # Verificar se o container est√° rodando
          if docker ps | grep -q ${CONTAINER_NAME}; then
            echo "‚úÖ Rollback container is running"

            # Verificar arquivos no volume
            FILE_COUNT=$(docker run --rm -v financial-agent-frontend-static:/files:ro alpine sh -c "ls /files/ | wc -l" || echo "0")
            if [ "$FILE_COUNT" -gt 0 ]; then
              echo "‚úÖ Rollback successful - static files restored ($FILE_COUNT files/folders)"
            else
              echo "‚ö†Ô∏è  Rollback container running but files may not be available"
            fi
          else
            echo "‚ùå Rollback verification failed - container not running"
            docker logs --tail 50 ${CONTAINER_NAME}
            exit 1
          fi

      - name: Rollback notification
        run: |
          echo "=================================="
          echo "‚ö†Ô∏è  Deployment was rolled back"
          echo "=================================="
          echo "Check logs for failure details:"
          docker logs --tail 100 ${CONTAINER_NAME}
